r""" This is the simulator that computes the right ascension and
declination of an exoplanet given the orbital parameters and the epochs of
observation.

The orbit calculator from the `orbitize.kepler` module  is used to do the
computations. The simulator is a callable class that takes in a tensor of
orbital parameters and returns a tensor of right ascension and declination
values.
"""

import torch
import numpy as np
from astropy.time import Time
from orbitize.kepler import calc_orbit


class Simulator:
    r""" Creates an orbit simulator for the Beta Pictoris system.

    Arguments:
        data_table (astropy.table.Table): Table containing the observations
            of the exoplanet. Must have columns "epoch", "quant1", "quant2",
            "quant1_err", and "quant2_err".
        scale (float): The scale factor to apply to the simulated observations.
    """

    def __init__(self, data_table, scale=1e6):
        
        self.data_table = data_table
        self.number_epochs = len(data_table)
        self.scale = scale

    def __call__(self, thetas: torch.Tensor) -> torch.Tensor:
        """
        Simulates observations of astronomical objects given a set of input parameters.

        Args:
            thetas (torch.Tensor): A tensor of shape (n_samples, 8) containing the input parameters for each sample.
                                    The 8 parameters are: sma, ecc, inc, aop, pan, tau, plx, mtot.

        Returns:
            torch.Tensor: A tensor of shape (n_samples, 2 * self.number_epochs) containing the simulated observations.
        """
        n_samples, _ = thetas.shape

        theta = thetas.T
        sma, ecc, inc, aop, pan, tau, plx, mtot = theta.numpy()
        
        inc = np.radians(inc)
        aop = np.radians(aop)
        pan = np.radians(pan)
        
        ra, dec, _ = calc_orbit(
            self.data_table["epoch"], 
            sma, 
            ecc, 
            inc, 
            aop, 
            pan,
            tau, 
            plx, 
            mtot, 
            use_gpu = True, 
            tau_ref_epoch=50000)

        # Adding Gaussian offets from observational uncertainties
        ra_err = self.data_table["quant1_err"]
        dec_err = self.data_table["quant2_err"]
        ra_err = np.random.normal(0, ra_err, (n_samples,len(ra_err)))
        dec_err = np.random.normal(0, dec_err, (n_samples,len(dec_err)))

        ra = ra.T + ra_err
        dec = dec.T + dec_err

        # calc_orbit returns numpy arrays, need to convert to tensors
        ra = torch.tensor(ra,dtype=torch.float32)
        dec = torch.tensor(dec,dtype=torch.float32)

        interleaved_tensor = torch.stack((ra, dec), dim=2)
        
        interleaved_tensor = interleaved_tensor.view(n_samples, -1)
        results = self.process(interleaved_tensor)

        return results
    
    def process(self, results: torch.Tensor) -> torch.Tensor:
        r""" Processes the results of the simulator

        Process the results of the simulator to make them more suitable for
        training. 

        Just dividing by the scale factor is enough because the simulated 
        data follows a Laplacian distribution which is symmetric at each 
        timestep. The demonstration is trivial. 

        Arguments:
            results (torch.Tensor): Tensor of right ascension and declination
                values generated by the simulator. This tensor is of shape
                (n_samples, 2 * n_epochs).

        Returns:
            torch.Tensor: Tensor of processed results. This tensor is of shape
                (n_samples, 2 * n_epochs).
        """

        return results / self.scale
    
    def get_scale(self):
        return self.scale
